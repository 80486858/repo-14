---
title: Parser
description: Utility
---


import Note from "../../src/components/Note"

<Note type="warning">
    It requires an extra dependency before using it.
</Note><br/>

This utility provides data parsing and deep validation using [Pydantic](https://pydantic-docs.helpmanual.io/).

**Key features**

* Defines data in pure Python classes, then parse, validate and extract only what you want
* Built-in envelopes to unwrap, extend, and validate popular event sources payloads
* Enforces type hints at runtime with user friendly errors

**Extra dependency**

<Note type="info">
    This will install <a href="https://github.com/samuelcolvin/pydantic">pydantic</a> and <a href="https://github.com/python/typing/tree/master/typing_extensions).">typing_extensions</a>
</Note><br/>

Install parser's extra dependencies using **`pip install aws-lambda-powertools[pydantic]`**.

## Defining models

You can define models to parse incoming events by inheriting from `BaseModel`.

```python:title=hello_world_model.py
from aws_lambda_powertools.utilities.parser import BaseModel
from typing import List, Optional

class OrderItem(BaseModel):
    id: int
    quantity: int
    description: str

class Order(BaseModel):
    id: int
    description: str
    items: List[OrderItem] # nesting models are supported
    optional_field: Optional[str] # this field may or may not be available when parsing
```

These are simply Python classes that inherit from BaseModel. **Parser** enforces type hints declared in your model at runtime.

<!-- TODO: We need a dedicated section to expand on these great features from Pydantic -->
<!-- The advantage here is that they can be [recursive, dumped as JSON, JSON Schema, Dicts, have validation and more](https://pydantic-docs.helpmanual.io/usage/models/). -->

<Note type="info">
    <strong>Looking to auto-generate models from JSON, YAML, JSON Schemas, OpenApi, etc?</strong>
    <br/><br/>
    Use Koudai Aono's <a href="https://github.com/koxudaxi/datamodel-code-generator">data model code generation tool for Pydantic</a>
</Note><br/>

## Parsing events

You can parse inbound events using **event_parser** decorator, or the standalone `parse` function. Both are also able to parse either dictionary or JSON string as an input.

### event_parser decorator

Use the decorator for fail fast scenarios where you want your Lambda function to raise an exception in the event of a malformed payload.

`event_parser` decorator will throw a `ModelValidationError` if your event cannot be parsed according to the model.

```python=:title=event_parser_decorator.py
from aws_lambda_powertools.utilities.parser import parse, ModelValidationError
from aws_lambda_powertools.utilities.typing import LambdaContext
import json

# Raw event for the Order model we've defined earlier
payload = {
    "id": 10876546789,
    "description": "My order",
    "items": [
        {
            "id": 1015938732,
            "quantity": 1,
            "description": "item xpto"
        }
    ]
}

@event_parser(model=Order) # highlight-line
def handler(event: Order, context: LambdaContext):
    print(event.id)
    print(event.description)
    print(event.items)

    order_items = [items for item in event.items]
    ...

handler(event=payload, context=LambdaContext())
handler(event=json.dumps(payload), context=LambdaContext()) # also works if event is a JSON string
```

### parse function

Use this standalone function when you want more control over the data validation process, for example returning a 400 error for malformed payloads.

```python:title=parse_standalone_example.py
from aws_lambda_powertools.utilities.parser import parse, ModelValidationError

# Raw event for the Order model we've defined earlier
payload = {
    "id": 10876546789,
    "description": "My order",
    "items": [
        {
            "id": 1015938732,
            "quantity": 1,
            "description": "item xpto"
        }
    ]
}

def my_function():
    try:
        parsed_payload: Order = parse(event=payload, model=HelloWorldModel) # highlight-line
        # payload dict is now parsed into our model
        return parsed_payload.items
    except ModelValidationError:
        return {
            "status_code": 400,
            "message": "Invalid order"
        }
```

### Data model validation

<Note type="warning">
    This is radically different from the <strong>Validator utility</strong> which validates events against JSON Schema.
</Note><br/>

You can use parser's validator for deep inspection of object values and complex relationships.

There are two types of class method decorators you can use:

* **`validator`** - Useful to quickly validate an individual field and its value
* **`root_validator`** - Useful to validate the entire model's data

Keep the following in mind regardless of which decorator you end up using it:

* You must raise either `ValueError`, `TypeError`, or `AssertionError` when value is not compliant
* You must return the value(s) itself if compliant

#### Validating fields

Quick validation to verify whether the field `message` has the value of `hello world`.

```python:title=deep_data_validation.py
from aws_lambda_powertools.utilities.parser import parse, BaseModel, validator

class HelloWorldModel(BaseModel):
    message: str

    @validator('message') # highlight-line
    def is_hello_world(cls, v):
        if v != "hello world":
            raise ValueError("Message must be hello world!")
        return v

parse(model=HelloWorldModel, event={"message": "hello universe"})
```

If you run as-is, you should expect the following error with the message we provided in our exception:

```
message
  Message must be hello world! (type=value_error)
```

Alternatively, you can pass `'*'` as an argument for the decorator so that you can validate every value available.

```python:title=validate_all_field_values.py
from aws_lambda_powertools.utilities.parser import parse, BaseModel, validator

class HelloWorldModel(BaseModel):
    message: str
    sender: str

    @validator('*') # highlight-line
    def has_whitespace(cls, v):
        if ' ' not in v:
            raise ValueError("Must have whitespace...")

        return v

parse(model=HelloWorldModel, event={"message": "hello universe", "sender": "universe"})
```

#### Validating entire model

`root_validator` can help when you have a complex validation mechanism. For example finding whether data has been omitted, comparing field values, etc.

```python:title=validate_all_field_values.py
from aws_lambda_powertools.utilities.parser import parse, BaseModel, validator

class UserModel(BaseModel):
    username: str
    password1: str
    password2: str

    @root_validator
    def check_passwords_match(cls, values):
        pw1, pw2 = values.get('password1'), values.get('password2')
        if pw1 is not None and pw2 is not None and pw1 != pw2:
            raise ValueError('passwords do not match')
        return values

payload = {
    "username": "universe",
    "password1": "myp@ssword",
    "password2": "repeat password"
}

parse(model=UserModel, event=payload)
```

<Note type="info">
    You can read more about validating list items, reusing validators, validating raw inputs, and a lot more in <a href="https://pydantic-docs.helpmanual.io/usage/validators/">Pydantic's documentation</a>.
</Note><br/>


## Built-in envelopes

**TBW**

## Extending built-in models

**TBW**
