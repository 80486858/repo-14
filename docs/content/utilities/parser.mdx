---
title: Parser
description: Utility
---


import Note from "../../src/components/Note"

<Note type="warning">
    It requires an extra dependency before using it.
</Note><br/>

This utility provides data parsing and deep validation using [Pydantic](https://pydantic-docs.helpmanual.io/).

**Key features**

* Defines data in pure Python classes, then parse, validate and extract only what you want
* Built-in envelopes to unwrap, extend, and validate popular event sources payloads
* Enforces type hints at runtime with user friendly errors

**Extra dependency**

<Note type="info">
    This will install <a href="https://github.com/samuelcolvin/pydantic">pydantic</a> and <a href="https://github.com/python/typing/tree/master/typing_extensions).">typing_extensions</a>
</Note><br/>

Install parser's extra dependencies using **`pip install aws-lambda-powertools[pydantic]`**.

## Defining models

You can define models to parse incoming events by inheriting from `BaseModel`.

```python:title=hello_world_model.py
from aws_lambda_powertools.utilities.parser import BaseModel

class HelloWorldModel(BaseModel):
    message: str

class NestedHelloWorldModel(BaseModel):
    payload: HelloWorldModel
```

These are simply Python classes that inherit from BaseModel. **Parser** enforces type hints declared in your model at runtime.

<!-- TODO: We need a dedicated section to expand on these great features from Pydantic -->
<!-- The advantage here is that they can be [recursive, dumped as JSON, JSON Schema, Dicts, have validation and more](https://pydantic-docs.helpmanual.io/usage/models/). -->

<Note type="info">
    <strong>Looking to auto-generate models from JSON, YAML, JSON Schemas, OpenApi, etc?</strong>
    <br/><br/>
    Use Koudai Aono's <a href="https://github.com/koxudaxi/datamodel-code-generator">data model code generation tool for Pydantic</a>
</Note><br/>

## Parsing events

You can parse inbound events using **event_parser** decorator, or the standalone `parse` function.

### event_parser decorator

Use the decorator for fail fast scenarios where you want your Lambda function to raise an exception in the event of a malformed payload.

`event_parser` decorator will throw a `ModelValidationError` if your event cannot be parsed according to the model.

```python=:title=event_parser_decorator.py
from aws_lambda_powertools.utilities.parser import parse, ModelValidationError
from aws_lambda_powertools.utilities.typing import LambdaContext

@event_parser(model=HelloWorldModel)
def handler(event, context: LambdaContext):
    pass

handler(event=payload, context=LambdaContext()
```

### parse function

Use this standalone function when you want more control over the data validation process, for example returning a 400 error for malformed payloads.

```python:title=parse_standalone_example.py
from aws_lambda_powertools.utilities.parser import parse, ModelValidationError

payload = {"message": "hello world"}

def my_function():
    try:
        parsed_payload = parse(event=payload, model=HelloWorldModel) # highlight-line
        # payload dict is now parsed into our model
        return assert parsed_payload.message == payload["message"]
    except ModelValidationError:
        return {
            "status_code": 400,
            "message": "Invalid input"
        }
```

## Built-in envelopes

**TBW**

## Extending built-in models

**TBW**

## Deep model validation

**TBW**
