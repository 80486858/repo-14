---
title: Parser
description: Utility
---


import Note from "../../src/components/Note"

<Note type="warning">
    It requires an extra dependency before using it.
</Note><br/>

This utility provides data parsing and deep validation using [Pydantic](https://pydantic-docs.helpmanual.io/).

**Key features**

* Defines data in pure Python classes, then parse, validate and extract only what you want
* Built-in envelopes to unwrap, extend, and validate popular event sources payloads
* Enforces type hints at runtime with user friendly errors

**Extra dependency**

<Note type="info">
    This will install <a href="https://github.com/samuelcolvin/pydantic">pydantic</a> and <a href="https://github.com/python/typing/tree/master/typing_extensions).">typing_extensions</a>
</Note><br/>

Install parser's extra dependencies using **`pip install aws-lambda-powertools[pydantic]`**.

## Defining models

You can define models to parse incoming events by inheriting from `BaseModel`.

```python:title=hello_world_model.py
from aws_lambda_powertools.utilities.parser import BaseModel
from typing import List, Optional

class OrderItem(BaseModel):
    id: int
    quantity: int
    description: str

class Order(BaseModel):
    id: int
    description: str
    items: List[OrderItem] # nesting models are supported
    optional_field: Optional[str] # this field may or may not be available when parsing
```

These are simply Python classes that inherit from BaseModel. **Parser** enforces type hints declared in your model at runtime.

<!-- TODO: We need a dedicated section to expand on these great features from Pydantic -->
<!-- The advantage here is that they can be [recursive, dumped as JSON, JSON Schema, Dicts, have validation and more](https://pydantic-docs.helpmanual.io/usage/models/). -->

<Note type="info">
    <strong>Looking to auto-generate models from JSON, YAML, JSON Schemas, OpenApi, etc?</strong>
    <br/><br/>
    Use Koudai Aono's <a href="https://github.com/koxudaxi/datamodel-code-generator">data model code generation tool for Pydantic</a>
</Note><br/>

## Parsing events

You can parse inbound events using **event_parser** decorator, or the standalone `parse` function. Both are also able to parse either dictionary or JSON string as an input.

### event_parser decorator

Use the decorator for fail fast scenarios where you want your Lambda function to raise an exception in the event of a malformed payload.

`event_parser` decorator will throw a `ModelValidationError` if your event cannot be parsed according to the model.

```python=:title=event_parser_decorator.py
from aws_lambda_powertools.utilities.parser import parse, ModelValidationError
from aws_lambda_powertools.utilities.typing import LambdaContext
import json

# Raw event for the Order model we've defined earlier
payload = {
    "id": 10876546789,
    "description": "My order",
    "items": [
        {
            "id": 1015938732,
            "quantity": 1,
            "description": "item xpto"
        }
    ]
}

@event_parser(model=Order) # highlight-line
def handler(event: Order, context: LambdaContext):
    print(event.id)
    print(event.description)
    print(event.items)

    order_items = [items for item in event.items]
    ...

handler(event=payload, context=LambdaContext())
handler(event=json.dumps(payload), context=LambdaContext()) # also works if event is a JSON string
```

### parse function

Use this standalone function when you want more control over the data validation process, for example returning a 400 error for malformed payloads.

```python:title=parse_standalone_example.py
from aws_lambda_powertools.utilities.parser import parse, ModelValidationError

# Raw event for the Order model we've defined earlier
payload = {
    "id": 10876546789,
    "description": "My order",
    "items": [
        {
            "id": 1015938732,
            "quantity": 1,
            "description": "item xpto"
        }
    ]
}

def my_function():
    try:
        parsed_payload: Order = parse(event=payload, model=HelloWorldModel) # highlight-line
        # payload dict is now parsed into our model
        return parsed_payload.items
    except ModelValidationError:
        return {
            "status_code": 400,
            "message": "Invalid order"
        }
```

### Error handling

**TBW**

## Built-in envelopes

**TBW**

## Extending built-in models

**TBW**

## Deep model validation

**TBW**
